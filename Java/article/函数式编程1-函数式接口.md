>>微信公众号：**[刘洋说](#liuyangspeak)**
>>关注可了解更多技术信息。问题或建议，请公众号留言;
>>**[如果你觉得[刘洋说]你有帮助，欢迎赞赏](#jump_20)[^1]**
>
>###内容目录
>
>[TOC]
>
>###  函数式接口
>  Java8 的接口有了重大变化，在接口类型上，重新定义了一种新的接口类型叫函数式接口。函数式接口有一个特点，就是整个接口里有且只有一个***抽象方法***。其次，接口中可以定义其他方法的实现，使用default 来保证兼容性。接口被实现的时，抽象方法必须被实现。default可以不用被实现，因为接口已经将其实现。当然这是Java8的新特性之一，但不是这次要说的重点。好下面来 java.util.function;可以找到Java8增加的全部函数式接口。
>```java
>/**
> *  节选中JDK中Predicate 接口源码
> * @since 1.8
> */
>@FunctionalInterface
>public interface Predicate<T> {
>
>    /**
>     * Evaluates this predicate on the given argument.
>     *
>     * @param t the input argument
>     * @return {@code true} if the input argument matches the predicate,
>     * otherwise {@code false}
>     */
>    boolean test(T t);
>
>    //此处省略约233行
>    // 
>}
>
>```
>在上述函数接口定义中和普通接口并不太多差异唯独多了一个@FunctionalInterface注解。该只是起来编译器检查作用，在实际程序运行中没有任何意义。和@Override 的注解作用相同。为了告诉程序员注意，这个接口是个函数式接口，不能随意在里面添加其他的抽象方法。
>### 函数式接口意义
>在了解函数式接口意义首先释义Java8的几个概念。
>**行为参数化**： 将函数作为参数传入方法的参数表中。
>>这里为什么称为函数不称为方法，个人理解类似于计算机组成原理中，指令和微指令的关系。一个指令是由多个微指令组合出来的。同样方法，在Java8把方法理解成一个实现完整的功能。而函数只是为了完成方法的一个步骤。虽然方法和函数在表现形式上是完全统一的。
>
>**谓词**：在行为参数化的时候，将函数作为参数传入参数表中，这时候这个函数就叫谓词。
>>其实就是函数接口中定义的函数。
>
>综上呢，函数式接口的意义在于在把函数作为方法传入参数表时候，以函数接口的形式接受参数。使得方法中对这个函数的实现不唯一。极大的增强的程序的灵活性。那以函数接口实现接受参数 
>原则上，只要函数类型，返回值相同。 函数都会被默认实现。
>### Demo
>使用Java8 提供最方便的Predicate<T>函数式接口来写个demo。
>Task:
>      1.将List中的非空字符串筛选出来。
>      2.将List中字符串长度大于5的筛选出来。
>      3.将List中字符串包含liu的筛选出来。
>传统思路就不在此阐述，主要讲Java8中的思路。
> 1，需要一个字符串集合过滤器。
> 2，该过滤器在我传入不同条件能够返回不同结果。
> 3，过滤器最好是一个接受集合，一个接受不同的过滤方法。
> 4，过滤器给我返回的结果类型都必须还是List<String>集合形式
>#### 定义过滤方法
>```java
>
>    public static boolean testEmpty(String test) {
>        return test.isEmpty();
>    }
>
>    public static boolean testLength(String test) {
>        return test.length() > 5;
>    }
>
>    public static boolean testConLiu(String test) {
>        return test.contains("liu");
>    }
>
>```
>
>
>#### 定义过滤器
>```java
>   /**
>     * 定义过滤器，这个过滤器作用，根据条件过滤List。
>     * 期望是传入list和函数，让这个过滤器自动帮我过滤。返回结果
>     * @param stringList  String 字符串
>     * @param predicate   函数式参数。接收一个函数。
>     * @return  list正确的结果
>     */
>public static List<String> filter(List<String> stringList, Predicate<String> predicate) {
>        List<String> resultList = new ArrayList<String>();
>        for (String str : stringList) {
>          //Predicate这个函数式接口只有一个函数式方法test
>           if (!predicate.test(str)) {
>                resultList.add(str);
>            }
>        }
>        return resultList;
>    }
>```
>#### 使用过滤器来过滤List
>>需要注意的一点的是 [::]符号 这个符号意思把这个方法作为一个函数值。 在使用对象变量时候用的是[.]。为了区分，所以Java8函数值采用[::],例如[String::valueof]代表String中valueOf()的这个方法。 
>```java
>    public static void main(String args[]) {
>        List<String> listS = Arrays.asList("134dff", "Asadf32", "B", "aliuyang", "", "12");
>        List<String> result = filter(listS, FilterStringList::testEmpty);
>// 传入测试非空函数和列表，返回非空列表集合
>        List<String> resultlength = filter(listS, FilterStringList::testLength);
>// 传入测试非长度函数和列表，返回长度大于5的列表集合
>        List<String> resultliu = filter(listS, FilterStringList::testConLiu);
>// 传入测试包含liu序列的函数和列表，返回包含liu列表集合
>        log(result);
>        log(resultlength);
>        log(resultliu);
>    }
>
>//输出结果函数
>    public static void log(List<String> stringList) {
>        for (String s : stringList) {
>            System.out.println("SystemOutLine:" + s);
>        }
>    }
>
>```
> *filter参数Predicate<T> predicate中的怎么就关联上了？*
>>  因为你定义的testLength 函数和系统提供的Predicate<T>接口函数中test方法定义的参数表和返回结果是一致的。这里的p.test()更像是一个testLength引用。和文章开头说的一样不要把这个test想成一个普通的方法，他只是一个方法的引用
>
>### 总结一下
>Java8增加了一个方法引用的新功能，他是通过函数接口实现的。
